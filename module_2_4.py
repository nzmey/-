print('\n')
'''Всё не так уж просто.'''

'''Исходные условия.'''
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]

'''Создаём списки.'''
primes = []
not_primes = []

'''Проверяем, есть ли в списке "numbers" число ДВА... А оно есть!!!'''
for k in range(len(numbers)):
    if numbers[k] == 2:
        primes.append(numbers[k])
# Понимаю, что несколько ходульное решение... Но ДВОЙКА - единственное чётное простое число.
# И как его грамотно впихнуть в нужный список - пока не слишком понятно...

'''Сортируем числа.'''
d = 3
i = 0
j = 0
for i in range(2, len(numbers)):
    d = int(numbers[i] / 2)  # Достаточно перебрать ПОЛОВИНУ набора множителей. Да и этого много...
    if d < 3:
        d = 3
        # Приходится принудительна увеличивать ПРЕДЕЛ ДИАПАЗОНА.
        # Иначе при перевой итерации "i" счётчик "j" не инициализируется.
    for j in range(2, d):
       if numbers[i] % j == 0:
            not_primes.append(numbers[i])
            break
    if numbers[i] % j != 0: # Понимаю, что не самая хорошая идея. Не в традициях ПИТОНА.
        primes.append(numbers[i])
# Однако, код будет работать, т.к. переменная-счётчик инициализируется заново при каждом запуске цилкла.
# Соответственно - инициализируется первым элементом последовательности, входящей в условие цикла.
# Это хорошо видно, т.к. каждая инициализация - подсвечивается розовым, если навести курсор.
# Правильней было бы завести отдельную переменную, присвоить ей значение "j" и дальше делать с ней
# всё что захочется. Хотя, тоже - так себе идея...

'''Выводим списки простых и непростых чисел.'''

print(f'Primes {primes}')
print(f'Not Primes{not_primes}')
